За решението на задачите да се използват типовете, които са посочени в условията. Решения, които обработват некоректно паметта или не спазват добрите практики от ООП и СДП, се оценяват с 0 точки. 
Елементите на едносвързан списък се представят чрез следния шаблон на структура: 

```c++
template <typename T> 
struct Node { 
    T value; 
    Node<T>* next; 
}; 
```

## Задача 1.
Нека е даден едносвързан списък. Всеки затворен интервал от валидни 0-базирани индекси `[i, j]` представя еднозначно негов подсписък, състоящ се от последователните елементи с индекси `k ∈ [i, j]`. Да се реализира шаблон на функция `reverseSublists(<тип> list, <тип> intervals)`, която приема указател към първи елемент на едносвързан списък `list` с елементи от тип `Т` и указател към първи елемент на едносвързан списък `intervals` с елементи от подходящ тип, представящ затворен интервал от 0-базирани индекси, и модифицира списъка `list` като последователно обръща огледално реда на елементите във всеки от подсписъците, представени чрез интервалите в `intervals`. Ако някой интервал съдържа невалидни индекси в `list`, да се хвърли подходящо изключение (`exception`).   

Пример: 
```
intervals                   [1, 3] → [2, 5] → [5, 6] 
list                        11 → 4 → 3 → 7 → 13 → 4 → 5 
след обръщане на [1, 3]     11 → 7 → 3 → 4 → 13 → 4 → 5 
след обръщане на [2, 5]     11 → 7 → 4 → 13 → 4 → 3 → 5 
след обръщане на [5, 6]     11 → 7 → 4 → 13 → 4 → 5 → 3 
```

## Задача 2.
Списък от цели числа се нарича `изцяло балансиран`, ако се състои от поне 3 елемента и всички елементи без първия и последния са равни на сбора от съседните си два елемента и изцяло небалансиран, ако в него няма нито един такъв елемент. Да се реализира функция `makeTotal`, която приема като параметър указател към първия елемент на едносвързан списък от цели числа и връща `true`, ако списъкът е `изцяло балансиран`. Ако списъкът не е `изцяло балансиран`, функцията да  връща `false` след като изтрие последователно от списъка от началото към края елементи, които изпълняват свойството за балансираност, докато списъкът стане изцяло небалансиран. 

За реализацията НЕ се допуска използването на допълнителни помощни структури от данни (т.е. външната (auxiliary) сложност по памет е O(1)). 
Примери: 
```
1) 1 → -4 → -5 → -1 → 4      true 
2) 10 → 5 → -5 → -15 → 2     false // -> delete 5
10 → -5 → -15 → 2                  // -> delete -5 
10 → -15 → 2 
(списъкът вече е изцяло небалансиран) 
```

## Задача 3.
Казваме, че дадена дума може да се прочете в стек от символи, ако можем да я получим при последователно изваждане на символи от стека като избирателно пропуснем някои от тях. Да се реализира функция `readAndDelete`, която по подаден стек от символи, представен чрез `std::stack` и дума (`word`) от тип `std::string`, връща като резултат дали думата може да се прочете в стека. Функцията да модифицира стека като изключи от него всички открити символи от `word` и да запазва останалите символи в същия ред. 

**Примери:** 
|word|stack|result|
|--|--|--|
| mom | ~~**m**~~ | true
 <br> | f | | 
 <br> | ~~**o**~~ | f | 
 <br> | o |         o | 
 <br> | ~~**m**~~ | | 

|word|stack|result|
|--|--|--|
| car | ~~**c**~~ | false
 <br> | c | | 
 <br> | d | c | 
 <br> | ~~**a**~~ | d | 
 <br> | y | y | 

