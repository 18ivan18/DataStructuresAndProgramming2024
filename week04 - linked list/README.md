# Свързан списък

Структурата данни *"Свързан списък"* представлява поредица от елементи, като всеки от тях съдържа не само информацията, която бихме пазили в масив, ами и информация кой е *следващият (и предишният)* елемент в поредицата.  
В най-стандартната имплементация, тази информация представлява указател към следващия (и предишния) елемент. Така лесно можем да обходим всички елементи от структурата - започвайки от първия, следваме неговия указател към следващия, от там към по-следващия и т.н.  
Допълнително ще пазим два указателя - към първия и към последния елемент на списъка. Това ще ни позволява лесно да добавяме елемент както в началото, така и в края на списъка.  
 
 ## Едносвързан списък (Singly Linked List)

![alt text](https://i.ibb.co/37WN76n/SLL.png)

 ### Сложност на операциите му:  
 - Добавяне на елемент на произволна позиция -> **O(n)**.  
В частност, добавяне на елемент в началото/края -> **O(1)**.  
-  Премахване на елемент от произволна позиция -> **O(n)**.   
В частност, премахване на елемент от началото -> **O(1)**.  
- "Преглед" на произволен елемент -> **O(n)**.  
В частност, в началото и в края  -> **O(1)**.  

 ## Двусвързан списък (Doubly Linked List)
  ### Сложност на операциите му:  
 - Добавяне на елемент на произволна позиция -> **O(n)**.  
В частност, добавяне на елемент в началото/края -> **O(1)**.  
-  Премахване на елемент от произволна позиция -> **O(n)**.   
В частност, премахване на елемент от началото/края -> **O(1)**.  
- "Преглед" на произволен елемент -> **O(n)**.  
В частност, в началото и в края  -> **O(1)**.  

Тук се появява и най-големият недостатък на списъците в сравнение с динамичния масив.  
**При списъците губим възможността за директен достъп**.  Няма начин, по който да индексираме k-тия елемент, без да минем през всички k-1 предходни.  сдп
# FAQ

## Какво е свързаният списък като структура от данни?
Крайна редица от хомогенни елементи. Операциите за включване и излючване са допустими на произволни места в редицата. Възможен е и достъп до всеки елемент в редицата. 

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2013/03/Linkedlist.png)

## Да си го напишем сами?
Има две основни физически представяния. Свързано с една връзка и свързано с две връзки. Връзката между отделните елементи се осъществява чрез указател към следващия елемент. За поддържане на структурата е достатъчен указател към началото на списъка.

## А да го ползваме на готово?
Макар и да го имаме в slt не го използваме самоцелно поради лоши сложности при добавяне и триене.
Повечето задачи използват тънкости при работата с отделните елементчета на списъка.

```c++
#include <list>
// ...
std::list<int> l;
```


# Задача 1
## Обръщане на свръзан списък
По даден указател към `head` - началото на свързан списък с една връзка, върнете *обърнатия списък*.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)
```c++
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```
**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)
```c++
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**
```c++
Input: head = []
Output: []
 ```

Constraints:

- The number of nodes in the list is the range `[0, 5000]`.
- `-5000 <= Node.val <= 5000`
 

**Follow up:** A linked list can be reversed either iteratively or recursively. Could you implement both?

# Задача 2
## Цикличен свързан списъл
По дадено начало към свързан списък определете дали той има цикъл в себе си.

Свързан списък има цикъл ако съществува негов елемент, който може да се достъпи повече от веднъж следвайки `next` указателя след като сме тръгнали от началото. Функцията да връща true/false.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)
```c++
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)
```c++
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where the tail connects to the 0th node.
```
**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)
```c++
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
 ```

**Constraints:**

- The number of the nodes in the list is in the range `[0, 10`<sup>`4`</sup>`]`.
- `-10`<sup>`5`</sup>` <= Node.val <= 10`<sup>`5`</sup>
- `pos` is `-1` or a **valid index** in the linked-list.
 

**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?


# Задача 3
## Сливане на два сортирани списъка
Слейте два сортирани свързани списъка в нов **сортиран** лист. Той трябва да бъде построен от вече съществуващите елементи на двата подадени списъка.


**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```c++
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]
```
**Example 2:**
```c++
Input: l1 = [], l2 = []
Output: []
```
**Example 3:**
```c++
Input: l1 = [], l2 = [0]
Output: [0]
 ```

**Constraints:**

- The number of nodes in both lists is in the range `[0, 50]`.
- `-100 <= Node.val <= 100`
- Both `l1` and `l2` are sorted in **non-decreasing** order.

# Задача 4
## Сортиране на свързан списък
По дадено началото на свързан списък с една връзка върнете листа след като го сортирате във възходящ ред.
 

**Example 1:**
![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```c++
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```c++
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```
**Example 3:**
```c++
Input: head = []
Output: []
 ```

**Constraints:**

- The number of nodes in the list is in the range [0, 5 * 10<sup>4</sup>].
- -10<sup>5</sup> <= Node.val <= 10<sup>5</sup>
 

**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?

# Задача 5
## Сбор на числа
Дадени са два не-празни свързани списъка представящи две неотрицателни цели числа. Техните цифри са записани в обратен ред и всеки възел съдържа една цифра. Съберете двете числа и върнете резултата като свързан списък.

Можем да предполагаме, че числата не започват с `0` освен самото число 0.

 

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)
```c++
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Example 2:**

```c++
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:**

```c++
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
 ```

**Constraints:**

- The number of nodes in each linked list is in the range `[1, 100].`
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.


# Задача 6
## Премахване на елемент от свързан списък
Напишете функция, която изтрива елемент на свързан списък с една връзка. Като аргумент на функцията обаче няма да бъде подадено началото на свързания списък, ами самият елемент, който трябва да изтрием.

Гарантирано е, че подаденият елемент за триене не е краят на списъка.

**Example 1**:

![](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)


```c++
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```
**Example 2**:

![](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```c++
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Example 3**:
```c++
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]
```

**Example 4**:
```c++
Input: head = [0,1], node = 0
Output: [1]
```

**Example 5**:
```c++
Input: head = [-3,5,-99], node = -3
Output: [5,-99]
 ```

**Constraints:**

- The number of the nodes in the given list is in the range **[2, 1000]**.
- `-1000 <= Node.val <= 1000`
- The value of each node in the list is unique.
- The node to be deleted is in the list and is not a tail node

# Задача 7
## Изтриване на n-ти елемент от края на листа
По дадено началото на свързан списък и число n, премахнете n-тия елемент от края на списъка и върнете началото.  

**Example 1:**

![image](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
```c++
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```
**Example 2:**
```c++
Input: head = [1], n = 1
Output: []
```
**Example 3:**
```c++
Input: head = [1,2], n = 1
Output: [1]
 ```

**Constraints:**

- The number of nodes in the list is `sz`.
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

# Задача 8
## Flatten a Multilevel Doubly Linked List

Даден ви е двойно свързан списък, който има върхове, които имат указател към следващия елемент, към предишния елемент и един допълнителен указател към наследник (child). Този допълнителен допълнителен указател може да сочи или да не сочи към отделен двойно свързан списък от същия вид. Тези списъци могат също да имат наследници и така се образуват много нива както е показано на картинката отдолу. 

![](https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg)

По дадено началото на първото ниво, изравнете списъка така, че всички върхове да са в двусързан списък на едно ниво. Ако `curr` е връх с наследници в един изравнен списък наследниците трябва да се появяват между `curr` и `curr->next`.

Върнете началото на новия списък. Всички указатели към наследници трябва да са насочени към `null`.

**Example 1:**
```c++
Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
```
![](https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg)

**Example 2:**
![](https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg)

```c++
Input: head = [1,2,null,3]
Output: [1,3,2]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:
```
![](https://assets.leetcode.com/uploads/2021/11/24/list.jpg)

**Example 3:**
```c++
Input: head = []
Output: []
Explanation: There could be empty list in the input.
```

## По-трудни задачи
### Задача 1 (от домашно)
Нека е дадена следната дефиниция на израз:
израз = неотрицателно цяло число | f(израз) | g(израз) | m(израз,израз), където:
- f(x) = (x * x) mod 100, където mod 100 връща остатъка при деление на 100
- g(x) = (x mod 5) ! , т.е. факториелът на остатъка на деленето на х на 5
- m(x,y) = min(x,y)

Например, f(m(25, g(14))) е валиден израз от горния тип и се оценява до 76, защото:
```
f(m(25,g(14))) =
    f(min(25, (14 mod 5)!) =
    f(min(25, 24)) =
    (24 * 24) mod 100 = 76
```
Даден е текстови файл с последователен достъп, в който са записани на отделен ред
цяло положително число N и след него пак на отделни редове N на брой изрази от
горния вид. Съдържанието на един **примерен** файл би бил:
```
3
f(15)
m(f(15),24)
f(m(25, g(14)))
```
Да се напише програма, която прочита информацията от един такъв файл и извежда
на стандартния изход на отделен ред всеки израз от файла и съответната му **крайна
оценка (без междинни стъпки).**

**Забележка:**
- Програмата трябва да работи за произволен израз от горния вид.
- При реализацията можете да използвате избрана от вас работеща реализация на
структурата или структурите, които ще използвате, включително и тези
предоставяни от STL.

### Задача 2 (от домашно)
Дадена е последователност от разноцветни топчета, залепени едно до друго и
номерирани с числата от **0** до **N-1**. Играта позволява да се изстрелват топчета с
определен цвят към редицата от топчета. Всяко изстреляно топче попада точно след
топчето с подаден номер, например **P**, измествайки всички топчета на позиции
по-големи от **P** с една позиция вдясно. Aко **P** e част от последователност от топчета с
еднакъв цвят с дължина **поне 3**, цялата последователност от едноцветни топчета бива
унищожена, а останалите топчета се залепят. Ако на мястото на залепянето се получи
последователност от топчета с еднакъв цвят с дължина поне **3**, процедурата се
повтаря, в противен случай можете да се изстреля ново топче. Играта приключва
когато не останат топчета в редицата.

Да се напише програма, която въвежда редица от **N** разноцветни топчета и изпълнява
**Q** броя заявки. Всяка заявка се състои от две цели числа **Pi** и **Ci** - номера на топчето,
към което трябва да се извърши изстрелването и цвета на топчето, което изстрелвате.
Цветовете трябва да се задават с числов код от 1 до N.
Допълнителни изисквания:
- Номерът на изстреляното топче е най-малкото, неизползвано за номер на
топче, естествено число.
- Приема се, че **Pi** винаги съществува (не е унищожено).
Програмата да намира броя на унищожените топчета след всеки изстрел. Ако след
поредния изстрел не останат никакви топчета, играта приключва и на всяка следваща
заявка трябва да се връща отговор "Game Over".

След приключване на заявките изведете получената редица от топчета или -1 ако
всички топчета са унищожени.

**Входни данни**

Първият ред на стандартния вход съдържа едно цяло число:
<br>N (броя топчета)

Вторият ред съдържа N цели числа:
<br>color1, color2, color3, ..., colorn (цветовете на топчетата)

Третият ред съдържа едно цяло число:
<br>Q (броя заявки)

Следват Q реда, състоящи се от по две цели числа:
Pi и Ci (номера на топчето, към което трябва да се стреля и цвета на топчето, което
се изстрелва)

**Ограничения**
- 0 <= N <= 10^5
- 0 <= Q <= 10^5
- 0 <= j <= N за color_j, Cj
- 0 <= i <= N + Q за Pi
  
**Изход**

Извежда Q + 1 реда.

Първите Q трябва да съдържат по едно цяло число - отговора на поредната заявка,
ако играта е приключила (редицата от топчета е празна) и се извежда "Game Over".

На последния ред се извежда крайното състояние на последователността от топчета,
ако в нея не са останали топчета се извежда "-1".

**Пример:**
```
N > 15
Colors > 2 2 1 1 1 2 2 2 2 3 3 3 1 1 2
Q > 4
Requests:
10 3
6 2
1 1
3 2
```
**Изход:**
```
4
13
Game Over
Game Over
-1
```
**Обяснение:**
```
След първия изстрел се унищожават следните 4 топчета:
2 2 1 1 1 2 2 2 2 (3 3 3 3) 1 1 2
След втория изстрел първо се унищожават следните 5 топчета:
2 2 1 1 1 (2 2 2 2 2) 1 1 2
при слепването се унищожават следните 5 топчета:
2 2 (1 1 1 1 1) 2
и накрая следните 3 топчета: (2 2 2)
Общият брой унищожени топчета е 13.
Всички топчета са унищожени:
Game Over
Всички топчета са унищожени:
Game Over
Крайното състояние на редицата е празно:
-1
```
**Пример 1**
```
N > 6
Colors > 1 2 2 2 1 1
Q > 5
Requests:
2 3
2 3
2 3
1 5
3 4
```
**Изход**
```
0
0
9
Game Over
Game Over
-1
```
**Обяснение**
```
След първият изстрел:
няма унищожени топчета: 1 2 2 3 2 1 1.
След вторият изстрел:
няма унищожени топчета: 1 2 2 3 3 2 1 1.
След третият изстрел:
първо се унищожават следните 3 топчета: 1 2 2 (3 3 3) 2 1 1;
след което се унищожават следните 3 топчета: 1 (2 2 2) 1 1;
и накрая следните 3 топчета: (1 1 1);
общо 9 унищожени топчета.
Всички топчета са унищожени:
Game Over
Всички топчета са унищожени:
Game Over
Крайното състояние на редицата е празно:
-1
```
**Пример 2**
```
N >10
Colors: 1 1 1 2 2 1 1 1 3 3
Q: 4
Requests:
1 4
9 5
9 6
3 2
```
**Изход**
```
0
0
0
7
1 1 4 3 3 6 5
```
**Обяснение**
```
След първият изстрел:
няма унищожени топчета: 1 1 4 1 2 2 1 1 1 3 3.
След вторият изстрел:
няма унищожени топчета: 1 1 4 1 2 2 1 1 1 3 3 5.
След третият изстрел:
няма унищожени топчета: 1 1 4 1 2 2 1 1 1 3 3 6 5.
След четвъртият изстрел:
първо се унищожават следните 3 топчета: 1 1 4 1 (2 2 2) 1 1 1 3 3 6 5;
след което се унищожават следните 4 топчета: 1 1 4 (1 1 1 1) 3 3 6 5;
общо 7 унищожени топчета.
Крайното състояние на редицата е:
1 1 4 3 3 6 5
```
### Задача 3 (от контролно)
Нека е даден следният шаблон на структура:
```c++
template <typename T>
struct Node {T data; Node<T> *next;};
```
При това условие, нека е даден списък L с елементи стекове. Възлите на L са от тип
Node<std::stack<T>>. Всеки стек може да съдържа различни елементи (**числа**).
Някои стекове могат да съдържат само четни, други само нечетни, а трети четни и
нечетни елементи. Казваме, че два стека са подобни, ако съдържат само четни или
само нечетни елементи. Да се дефинира подходящо параметризирана функция
concatSimilarStackElements(L), която конкатенира всички <u>последователни</u> стекове,
които са подобни и връща указател към новия свързан списък.

**Пример:** Даден е списък от стекове. Първите два стека са с четни числа. Затова
вторият се конкатенира в началото на първия, запазвайки реда на добавяне на
елементите. Третият и четвъртия стек са с нечетни числа и те също се конкатенират.
Петият е с четни числа, но преди него и след него няма други стекове с четни
елементи и той остава непроменен. Последния стек съдържа различни елементи и
също не се конкатенира.
```
върхове
6
4 0 7 1 0 2
2 → 8 → 5 → 9 → 2 → 1
върхове
0
8 1
6 9
4 7 0 2
2 → 5 → 2 → 1
```
### Задача 4.
Разглеждаме езика OYAML (“Oversimplified YAML”), опростен вариант на езика YAML
(“Yet Another Markup Language”), което е човешки-четим език за сериализация на
данни.

OYAML файловете се речници, съставени от двойки ключ-стойност. Ключовете са
низове, състоящи се само от малки латински букви, а съответните им стойности са два
вида - прости и съставни. Простите стойности са низове с произволна дължина, но без
нови редове, а сложните - цели съставни речници.

В OYMAL формата ключовете винаги са следвани от двоеточие и интервал, след което
е стойността на ключа, ако е проста. Ако стойността е съставна, вложеният речник
започва от следващия ред.

Ключове са предхождани от интервали. Броят на интервалите е равен на нивото на
влагане на речника. В следния пример:
```
dictName: main dictionary
value: 5
innerDict1:
dictName: first inner dictionary
value: 10
anotherValue: 100
innerDict2:
dictName: second inner dictionary
value: 15
purpose: show more levels of nesting
innerDict3:
dictName: innermost dictionary
value: 20
someOtherKey: anything here
```
Речникът с име `main dictionary` е основен за файла и е с ниво на влагане 0. `first inner
dictionary` и `second inner dictionary` са с вложени в `main dictionary`, a `innermost
dictionary` е вложен в `second inner dictionary`.

Дефинирайте тип данни YAMLDocument, подходящ за представяне в паметта на
данните от OYAML файл. Да се поддържат следните операции:
- insert(locatorKey, newKey, newValue): измежду всички вложени речници на
всички нива, намира някой речник, съответен на ключ locatorKey и добавя към
него нова двойка ключ-проста стойност. Например,
insert(`innerDict3`, `test`, `5`)
ще вмъкне `test: 5` в `innermost dictionary`.
Ако такъв речник не е намерен (и в частност, ако ключът за търсене е празен
низ), се вмъква в главния речник
- find(path), където path е символен низ от вида `<key1>/<key2>/.../<keyN>`.
Ако key1, key2,...,keyN-1 са последователно вложени един в друг речници, а
keyN има проста стойност, да се върне стойността на keyN. В противен случай
да се върне празен низ. Например:
find(`innerDict2/innerDict3/value`)
ще върне низа `20`, а
find(`value`)
ще върне низа `5`