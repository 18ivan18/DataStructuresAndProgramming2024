# Графи (Graphs)

## Видове графи:

- ориентиран / неориентиран
- тегловен / нетегловен
- обикновен граф / мултиграф

## Основни операции:

Графите (като абстрактен тип данни) трябва да поддържат (част) от следните операции:

- **addVertex** - добавяне на нов връх
- **removeVertex** - премахване на връх
- **addEdge** - добавяне на ново ребро
- **removeEdge** - премахване на ребро
- **getSuccessors** - взимане на наследниците на връх (при ориентирани графи)
- **getPredecessors** - взимане на предшествениците на връх (при ориентирани графи)
- **adjacent** - взимане на съседните върхове на даден връх (при неориентирани графи)

## Представяне на графи:

Графите могат да се представят по различен начин в зависимост от това **_какъв граф ни трябва и какви са целите ни._** Реализация на граф **_за общо предназначение няма_**. Това е и причината в стандартната библиотека (stl) да нямаме структура граф.

### 1. Матрица на съседство (Adjacency matrix):

В клетка M[i][j] е записано теглото на реброто от връх i до връх j, ако има такова, или 0, ако няма такова.

![alt_text](https://i.ibb.co/TBw1T2t/Adj-matrix.png)

| Операция        | Сложност |                    |
| --------------- | -------- | ------------------ |
| addVertex       | O(n)     |                    |
| removeVertex    | O(n)     |                    |
| addEdge         | O(1)     | :heavy_check_mark: |
| removeEdge      | O(1)     | :heavy_check_mark: |
| getSuccessors   | O(n)     |                    |
| getPredecessors | O(n)     |                    |

**Памет** - O(n^2) :x:

_Забележка 1:_ Тази реализация не ни дава възможност да поддържаме мултиграфи.  
_Забележка 2:_ Тази реализация не ни позволява да имаме ребро с тегло 0 (двусмислие - нямаме ребро или ~~имаме ребро с тегло 0~~).

### 2. Списък на съседство (Adjacency list):

Всеки връх v пази списък с върховете, към които сочат ребрата, излизащи от v. Ако графът е тегловен, към всеки връх от списъка с наследниците се добавя допълнително поле, показващо цената на реброто до него.

![alt_text](https://i.ibb.co/yPPp6Ds/adj-List-Graph.jpg)

| Операция        | Сложност |                    |
| --------------- | -------- | ------------------ |
| addVertex       | O(1)     | :heavy_check_mark: |
| removeVertex    | O(n+m)   |                    |
| addEdge         | O(1)     | :heavy_check_mark: |
| removeEdge      | O(m)     |                    |
| getSuccessors   | O(m)     |                    |
| getPredecessors | O(n+m)   |                    |

**Памет** - O(n+m) :heavy_check_mark:

### 3. Списък на ребра (Edge list):

Представя се чрез списък от всички наредени двойки <v_i, v_j>, за които е вярно, че има ребро от v_i до v_j. Ако графът е тегловен, то вместо наредени двойки поддържаме наредени тройки с трети елемент - теглото на даденото ребро.

![alt_text](https://i.ibb.co/yVS2sBM/edge-List-Graph.jpg)

| Операция        | Сложност |                    |
| --------------- | -------- | ------------------ |
| addVertex       | O(1)     | :heavy_check_mark: |
| removeVertex    | O(m)     |                    |
| addEdge         | O(1)     | :heavy_check_mark: |
| removeEdge      | O(m)     |                    |
| getSuccessors   | O(m)     |                    |
| getPredecessors | O(m)     |                    |

**Памет** - O(m) :heavy_check_mark:

## Алгоритми върху графи:

- Обхождане в ширина (**BFS**)
- Обхождане в дълбочина (**DFS**) - Итеративно
- Обхождане в дълбочина (**DFS**) - Рекурсивно
- Проверка дали граф е **двуделен**
- **Dijkstra**'s algorithm

## FAQ

### Какво да правя ако съм на изпит и нямам време да пиша цяла структура граф?

Структурата граф сама по себе си не е толкова времеемка за писане, но въпреки това ето няколко лесни начина за представяне на граф.

**Чрез списък на съседство:**

```c++
    int n, m;
    std::cin >> n >> m;
    std::vector<std::list<int>> undirectedgraph(n);
    for (size_t i = 0; i < m; i++)
    {
        int from, to;
        std::cin >> from >> to;
        undirectedgraph[from].push_back(to);
        undirectedgraph[to].push_back(from);
    }
```

**Символен граф:**

```c++
   int from, to;
   std::unordered_map<int, std::list<int>> g;
   while(std::cin >> form >> to) {
    g[from].push_back(to);
    g[to].push_back(from);
   }
```

# Основни графови алгоритми

## Задача 1

Имплементирайте класове за ориентиран и неориентиран граф.
Нека съдържат методите:

- toString()

и предефиниран оператор за изход

- operator<<(...)

Нека ориентираният граф да има следните методи:

- indegree(int v)
- outdegree(int v)
- reverse()

**Бонус:** Направете абстрактен клас граф, който е наследен от ориентирания и
неориентирания граф.

## Неориентирани графи

## Задача 2

Имплементирайте простичък graph-processing API за неориентиран граф със следните
методи:

- degree(Graph G, inv v) -> степента на върха v
- maxDegree(Graph G)
- avgDegree(Graph G)
- numberOfSelfLoops(Graph G)

**Note.**

Design pattern. Decouple graph data type from graph processing.

- Create a Graph object.
- Pass the Graph to a graph-processing routine.
- Query the graph-processing routine for information.

### Каква е сложността на всеки един от алгоритмите по време и памет?

Това условие се
отнася за всяка една задача.

## Задача 3

Имплементирайте Graph client, който използва DFS и BFS за неориентиран граф, за да
провери дали има път от даден връх до всички други. Имплементирайте DFS
рекурсивно и нерекурсивно.

## Задача 4

Имплементирайте Graph client за неориентиран граф, който намира броят на
свързаните компоненти в граф, както и отговаря на въпроса дали 2 върха са свързани.

## Задача 5

Имплементирайте Graph client, който проверява дали неориентиран граф е:

- цикличен
- двуделен

## Задача 6

### Symbol graph.

Често срещано приложение е обработването на графи, дефинирани чрез
файлове, стрингове и/или индекси, които не са цели числа. Трябва да се справим с
входни данни със следните свойства:

- Имената на върховете са низове.
- Специално обозначен разделител дели имената на върховете.
- Всеки ред съдържа два върха, разделени с оказания разделител.
- Броят върхове и ребра не са експлицитно посочени.

Бонус, ако го имплементирате, така че да чете подаденият вход само веднъж.
Обяснение: интуитивната идея е да се прочете входът веднъж, за да се преброят
върховете, и втори път, за да се добавят ребрата.

Примерен тестов клиент:

```c++
std::string filename = args[0];
std::string delim = args[1];
SymbolGraph sg = new SymbolGraph(filename, delim);
Graph G = sg.G();
while (std::cin)
{
    std::string source;
    std::cin.getline(source);
    for (int w : G.adj(sg.index(source))){
        std::cout << " " << sg.name(w);
    }
    std::cout << std::endl;
}
```

## Ориентирани графи

## Задача 7

Имплементирайте Graph client, който сортира топологично DAG.

## Задача 8

Имплементирайте Graph client, който проверява дали ориентиран граф:

- е цикличен
- имплементира алгоритъмът на Kosaraju за силно свързани компоненти.

## Задача 9

Имплементирайте Graph client, който проверява дали ориентиран граф има Ойлеров:

- път
- цикъл

# TODO:

- min cut max flow
- bridges
